# 순환이란?
- 알고리즘, 함수가 수행 도중 **자기 자신을 다시 호출해** 문제를 해결하는 기법
- 본질적으로 **순환적 문제, 그런 자료구조**를 다루는 프로그램에 적합

## 팩토리얼 프로그램

```
int factorial(int n)
{
    if( n<= 1 ) return(1);
    else return (n * factorial(n-1) );
}
```
**팩토리얼 함수의 호출 순서**

<img width="237" height="224" alt="image" src="https://github.com/user-attachments/assets/52f69d59-33d0-44ee-a680-855f6acc602a" />

- **if( n<= 1) return 1** : 순환 멈추는 부분 (이게 없으면 오류)
- **else return n * factorial(n-1)** : 순환 호출 부분

- n=5일때 호출순서
```
factorial(5) = 5 * factorial(4) 
= 5 * 4 * factorial(3) 
= 5 * 4 * 3 * factorial(2)
= 5 * 4 * 3 * 2 * factorial(1)
= 5 * 4 * 3 * 2 * 1
= 120
```
- **순환 알고리즘 <-> 반복 알고리즘**: 바꿔 작성가능
- 순환, 반복 각각 사용시 비효율적이게 되는 게 있음
- **(ex 피보나치 수열은 순환 호출 사용시 비효율적), (거듭제곱 값은 순환이 더 효율적)**

## 피보나치 수열
**피보나치 수열: 앞의 두 숫자를 더해서 뒤의 숫자를 만듦**

<img width="365" height="122" alt="image" src="https://github.com/user-attachments/assets/f0e8d075-7459-4a8d-9d73-a24ec764fd4a" />

```
*순환적 피보나치 수열*
int fib(int n)
{
    if( n==0 ) return 0; // n이 0일때
    if( n==1 ) return 1; // n이 1일때
    return ( fib(n-1) + fib(n-2) ); // n이 0,1이 아닌 그 외 숫자일때
}

순환호출이 깊어질수록 상당히 비효율적임!
시간 복잡도 O(2^n)
```

```
*반복적 피보나치 수열* <시험 나올 가능성 있음. 특히 수행시간 체크하는 부분>
int fib_iter(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
        
    int pp = 0;	
    int p = 1;
    int result = 0;
        
    for (int i = 2; i <= n; i++) {
        result = p + pp;
        pp = p;
        p = result;
    }
    return result;
}
```

## 하노이 탑 <시험, 코드 결과를 손으로 작성해보기>












---
**프로젝트 또는 솔루션 열기 -> 파일이름이 있는 "폴더" 클릭 -> .sln파일 선택 -> 실행됨**

